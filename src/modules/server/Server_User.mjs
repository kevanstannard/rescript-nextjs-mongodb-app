// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Bcrypt from "bcrypt";
import * as Nanoid from "nanoid";
import * as MongoDb from "../../bindings/MongoDb.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Common_User from "../common/Common_User.mjs";
import * as Server_Email from "./Server_Email.mjs";
import * as Server_ReCaptcha from "./Server_ReCaptcha.mjs";

var User = {};

function toCommonUser(user) {
  return {
          id: Curry._1(MongoDb.ObjectId.toString, user._id),
          email: user.email,
          emailChange: user.emailChange
        };
}

function toCommonUserDto(user) {
  return Common_User.User.toDto(toCommonUser(user));
}

function getCollection(client) {
  var db = client.db();
  return db.collection("users");
}

function getStats(client) {
  return getCollection(client).stats();
}

function hashPassword(password) {
  return Bcrypt.genSalt(10).then(function (salt) {
              return Bcrypt.hash(password, salt);
            });
}

function comparePasswords(password, passwordHash) {
  return Bcrypt.compare(password, passwordHash);
}

function makeActivationKey(param) {
  return Curry._1(Nanoid.nanoid, undefined);
}

function makeResetPasswordKey(param) {
  return Curry._1(Nanoid.nanoid, undefined);
}

function makeEmailChangeKey(param) {
  return Curry._1(Nanoid.nanoid, undefined);
}

function signupToUser(signup) {
  var now = new Date();
  return hashPassword(signup.password).then(function (passwordHash) {
              return Promise.resolve({
                          _id: Curry._1(MongoDb.ObjectId.make, undefined),
                          email: signup.email,
                          emailVerified: false,
                          emailChange: undefined,
                          emailChangeKey: undefined,
                          emailChangeKeyExpiry: undefined,
                          passwordHash: passwordHash,
                          created: now,
                          updated: now,
                          activationKey: Curry._1(Nanoid.nanoid, undefined),
                          isActivated: false,
                          resetPasswordKey: undefined,
                          resetPasswordExpiry: undefined
                        });
            });
}

function findUserByObjectId(client, objectId) {
  return getCollection(client).findOne({
                _id: objectId
              }).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function findUserByStringId(client, userId) {
  var userId$1 = MongoDb.ObjectId.fromString(userId);
  if (userId$1.TAG === /* Ok */0) {
    return getCollection(client).findOne({
                  _id: userId$1._0
                }).then(function (prim) {
                if (prim === undefined) {
                  return ;
                } else {
                  return Caml_option.some(prim);
                }
              });
  } else {
    return Promise.resolve(undefined);
  }
}

function insertUser(client, user) {
  return getCollection(client).insertOne(user).then(function (insertResult) {
              return findUserByObjectId(client, insertResult.insertedId).then(function (user) {
                          if (user !== undefined) {
                            return Promise.resolve(user);
                          } else {
                            return Js_exn.raiseError("User not found after insert");
                          }
                        });
            });
}

function findUserByEmail(client, email) {
  return getCollection(client).findOne({
                email: email
              }).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function updateUserPassword(client, userId, password) {
  var userId$1 = MongoDb.ObjectId.fromString(userId);
  if (userId$1.TAG === /* Ok */0) {
    return MongoDb.Collection.updateOneWithSet(getCollection(client), userId$1._0, {
                password: password
              });
  } else {
    return Js_exn.raiseError(userId$1._0);
  }
}

function updateEmailVerified(client, userId, emailVerified) {
  var userId$1 = MongoDb.ObjectId.fromString(userId);
  if (userId$1.TAG === /* Ok */0) {
    return MongoDb.Collection.updateOneWithSet(getCollection(client), userId$1._0, {
                emailVerified: emailVerified
              });
  } else {
    return Js_exn.raiseError(userId$1._0);
  }
}

function checkIfEmailIsTaken(client, email) {
  return getCollection(client).find({
                  $or: [
                    {
                      email: email
                    },
                    {
                      emailChange: email
                    }
                  ]
                }).toArray().then(function (users) {
              return Promise.resolve(users.length > 0);
            });
}

function validateEmailIsAvailable(client, email) {
  var emailTrimmed = $$String.trim(email);
  return checkIfEmailIsTaken(client, emailTrimmed).then(function (isTaken) {
              return Promise.resolve(isTaken ? "EmailNotAvailable" : undefined);
            });
}

function validateReCaptchaToken(token) {
  if (token !== undefined) {
    return Server_ReCaptcha.verifyToken(token).then(function (result) {
                if (result.TAG === /* Ok */0) {
                  return Promise.resolve(undefined);
                } else {
                  return Promise.resolve("ReCaptchaInvalid");
                }
              });
  } else {
    return Promise.resolve("ReCaptchaEmpty");
  }
}

function validateSignup(client, signup) {
  var validation = Common_User.Signup.validateSignup(signup);
  if (Common_User.Signup.hasErrors(validation)) {
    return Promise.resolve(validation);
  }
  var emailTrimmed = $$String.trim(signup.email);
  var emailPromise = validateEmailIsAvailable(client, emailTrimmed);
  var reCaptchaPromise = validateReCaptchaToken(signup.reCaptcha);
  return emailPromise.then(function (emailError) {
              return reCaptchaPromise.then(function (reCaptchaError) {
                          return Promise.resolve({
                                      email: emailError,
                                      password: undefined,
                                      reCaptcha: reCaptchaError
                                    });
                        });
            });
}

function signup(client, signup$1) {
  return validateSignup(client, signup$1).then(function (validation) {
              if (Common_User.Signup.isValid(validation)) {
                return signupToUser(signup$1).then(function (param) {
                              return insertUser(client, param);
                            }).then(function (user) {
                            var activationKey = user.activationKey;
                            if (activationKey === undefined) {
                              return Js_exn.raiseError("Activation key not found after signup");
                            }
                            var userId = Curry._1(MongoDb.ObjectId.toString, user._id);
                            return Server_Email.sendActivationEmail(userId, user.email, activationKey).then(function (param) {
                                        return Promise.resolve({
                                                    TAG: /* Ok */0,
                                                    _0: validation
                                                  });
                                      });
                          });
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: validation
                          });
              }
            });
}

function login(client, login$1) {
  return findUserByEmail(client, login$1.email).then(function (user) {
              if (user !== undefined) {
                if (user.isActivated) {
                  return Bcrypt.compare(login$1.password, user.passwordHash).then(function (compareResult) {
                              return Promise.resolve(compareResult ? ({
                                              TAG: /* Ok */0,
                                              _0: user
                                            }) : ({
                                              TAG: /* Error */1,
                                              _0: "PasswordInvalid"
                                            }));
                            });
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: "AccountInactive"
                            });
                }
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
            });
}

function setIsActivated(client, userId) {
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, {
              isActivated: true,
              activationKey: null
            });
}

function activate(client, userId, activationKey) {
  return findUserByObjectId(client, userId).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
              if (user.isActivated) {
                return Promise.resolve({
                            TAG: /* Ok */0,
                            _0: undefined
                          });
              }
              var userActivationKey = user.activationKey;
              if (userActivationKey !== undefined) {
                if (userActivationKey === activationKey) {
                  return setIsActivated(client, userId).then(function (_updateResult) {
                              return Promise.resolve({
                                          TAG: /* Ok */0,
                                          _0: undefined
                                        });
                            });
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: "IncorrectActivationKey"
                            });
                }
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "ActivationKeyMissing"
                          });
              }
            });
}

function setPassword(client, userId, password) {
  return hashPassword(password).then(function (passwordHash) {
              return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, {
                          passwordHash: passwordHash,
                          resetPasswordKey: null,
                          resetPasswordExpiry: null
                        });
            });
}

function changePassword(client, userId, changePassword$1) {
  var validation = Common_User.ChangePassword.validateChangePassword(changePassword$1);
  if (Common_User.ChangePassword.hasErrors(validation)) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: validation
              });
  } else {
    return findUserByObjectId(client, userId).then(function (user) {
                if (user !== undefined) {
                  if (user.isActivated) {
                    return Bcrypt.compare(changePassword$1.currentPassword, user.passwordHash).then(function (compareResult) {
                                if (compareResult) {
                                  return setPassword(client, userId, changePassword$1.newPassword).then(function (param) {
                                              return Promise.resolve({
                                                          TAG: /* Ok */0,
                                                          _0: validation
                                                        });
                                            });
                                } else {
                                  return Promise.resolve({
                                              TAG: /* Error */1,
                                              _0: {
                                                changePassword: "CurrentPasswordInvalid",
                                                currentPassword: undefined,
                                                newPassword: undefined,
                                                newPasswordConfirm: undefined
                                              }
                                            });
                                }
                              });
                  } else {
                    return Promise.resolve({
                                TAG: /* Error */1,
                                _0: {
                                  changePassword: "AccountNotActivated",
                                  currentPassword: undefined,
                                  newPassword: undefined,
                                  newPasswordConfirm: undefined
                                }
                              });
                  }
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changePassword: "UserNotFound",
                                currentPassword: undefined,
                                newPassword: undefined,
                                newPasswordConfirm: undefined
                              }
                            });
                }
              });
  }
}

export {
  User ,
  toCommonUser ,
  toCommonUserDto ,
  getCollection ,
  getStats ,
  hashPassword ,
  comparePasswords ,
  makeActivationKey ,
  makeResetPasswordKey ,
  makeEmailChangeKey ,
  signupToUser ,
  findUserByObjectId ,
  findUserByStringId ,
  insertUser ,
  findUserByEmail ,
  updateUserPassword ,
  updateEmailVerified ,
  checkIfEmailIsTaken ,
  validateEmailIsAvailable ,
  validateReCaptchaToken ,
  validateSignup ,
  signup ,
  login ,
  setIsActivated ,
  activate ,
  setPassword ,
  changePassword ,
  
}
/* bcrypt Not a pure module */
