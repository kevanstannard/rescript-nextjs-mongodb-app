// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Bcrypt from "bcrypt";
import * as Nanoid from "nanoid";
import * as MongoDb from "../../bindings/MongoDb.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Common_Date from "../common/Common_Date.mjs";
import * as Common_User from "../common/Common_User.mjs";
import * as Server_Email from "./Server_Email.mjs";
import * as Server_ReCaptcha from "./Server_ReCaptcha.mjs";
import AddHours from "date-fns/addHours";

function idField(id) {
  return {
          _id: id
        };
}

function emailField(email) {
  return {
          email: email
        };
}

function emailQuery(email) {
  return {
          $or: [
            {
              email: email
            },
            {
              emailChange: email
            }
          ]
        };
}

function activationFields(isActivated, activationKey) {
  return {
          isActivated: isActivated,
          activationKey: activationKey
        };
}

function resetPasswordFields(resetPasswordKey, resetPasswordExpiry) {
  return {
          resetPasswordKey: resetPasswordKey,
          resetPasswordExpiry: resetPasswordExpiry
        };
}

function passwordFields(passwordHash, resetPasswordKey, resetPasswordExpiry) {
  return {
          passwordHash: passwordHash,
          resetPasswordKey: resetPasswordKey,
          resetPasswordExpiry: resetPasswordExpiry
        };
}

function emailChangeFields(emailChange, emailChangeKey, emailChangeKeyExpiry) {
  return {
          emailChange: emailChange,
          emailChangeKey: emailChangeKey,
          emailChangeKeyExpiry: emailChangeKeyExpiry
        };
}

function emailFields(email, emailChange, emailChangeKey, emailChangeKeyExpiry) {
  return {
          email: email,
          emailChange: emailChange,
          emailChangeKey: emailChangeKey,
          emailChangeKeyExpiry: emailChangeKeyExpiry
        };
}

var User = {
  idField: idField,
  emailField: emailField,
  emailQuery: emailQuery,
  activationFields: activationFields,
  resetPasswordFields: resetPasswordFields,
  passwordFields: passwordFields,
  emailChangeFields: emailChangeFields,
  emailFields: emailFields
};

function toCommonUser(user) {
  return {
          id: Curry._1(MongoDb.ObjectId.toString, user._id),
          email: user.email,
          emailChange: Caml_option.nullable_to_opt(user.emailChange)
        };
}

function toCommonUserDto(user) {
  return Common_User.User.toDto(toCommonUser(user));
}

function toNullCommonUserDto(user) {
  var userDto = Belt_Option.map(user, toCommonUserDto);
  if (userDto !== undefined) {
    return userDto;
  } else {
    return null;
  }
}

function getCollection(client) {
  var db = client.db();
  return db.collection("users");
}

function getStats(client) {
  return getCollection(client).stats();
}

function hashPassword(password) {
  return Bcrypt.genSalt(10).then(function (salt) {
              return Bcrypt.hash(password, salt);
            });
}

function comparePasswords(password, passwordHash) {
  return Bcrypt.compare(password, passwordHash);
}

var makeActivationKey = Nanoid.nanoid;

var makeResetPasswordKey = Nanoid.nanoid;

var makeEmailChangeKey = Nanoid.nanoid;

function makeEmailChangeKeyExpiry(param) {
  return AddHours(new Date(), 1);
}

function makeResetPasswordExpiry(param) {
  return AddHours(new Date(), 1);
}

function signupToUser(signup) {
  var now = new Date();
  return hashPassword(signup.password).then(function (passwordHash) {
              return Promise.resolve({
                          _id: Curry._1(MongoDb.ObjectId.make, undefined),
                          email: signup.email,
                          emailChange: null,
                          emailChangeKey: null,
                          emailChangeKeyExpiry: null,
                          passwordHash: passwordHash,
                          created: now,
                          updated: now,
                          activationKey: Curry._1(makeActivationKey, undefined),
                          isActivated: false,
                          resetPasswordKey: null,
                          resetPasswordExpiry: null
                        });
            });
}

function findUserByObjectId(client, userId) {
  var query = {
    _id: userId
  };
  return getCollection(client).findOne(query).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function findUserByStringId(client, userId) {
  var userId$1 = MongoDb.ObjectId.fromString(userId);
  if (userId$1.TAG === /* Ok */0) {
    return findUserByObjectId(client, userId$1._0);
  } else {
    return Promise.resolve(undefined);
  }
}

function insertUser(client, user) {
  return getCollection(client).insertOne(user).then(function (insertResult) {
              return findUserByObjectId(client, insertResult.insertedId).then(function (user) {
                          if (user !== undefined) {
                            return Promise.resolve(user);
                          } else {
                            return Js_exn.raiseError("User not found after insert");
                          }
                        });
            });
}

function findUserByEmail(client, email) {
  var query = {
    email: email
  };
  return getCollection(client).findOne(query).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function checkIfEmailIsTaken(client, email) {
  return getCollection(client).find(emailQuery(email)).toArray().then(function (users) {
              return Promise.resolve(users.length > 0);
            });
}

function validateEmailIsAvailable(client, email) {
  var emailTrimmed = $$String.trim(email);
  return checkIfEmailIsTaken(client, emailTrimmed).then(function (isTaken) {
              return Promise.resolve(isTaken ? "EmailNotAvailable" : undefined);
            });
}

function validateReCaptchaToken(token) {
  if (token !== undefined) {
    return Server_ReCaptcha.verifyToken(token).then(function (result) {
                if (result.TAG === /* Ok */0) {
                  return Promise.resolve(undefined);
                } else {
                  return Promise.resolve("ReCaptchaInvalid");
                }
              });
  } else {
    return Promise.resolve("ReCaptchaEmpty");
  }
}

function validateSignup(client, signup) {
  var errors = Common_User.Signup.validateSignup(signup);
  if (Common_User.Signup.hasErrors(errors)) {
    return Promise.resolve(errors);
  }
  var emailTrimmed = $$String.trim(signup.email);
  var emailPromise = validateEmailIsAvailable(client, emailTrimmed);
  var reCaptchaPromise = validateReCaptchaToken(signup.reCaptcha);
  return emailPromise.then(function (emailError) {
              return reCaptchaPromise.then(function (reCaptchaError) {
                          return Promise.resolve({
                                      signup: undefined,
                                      email: emailError,
                                      password: undefined,
                                      reCaptcha: reCaptchaError
                                    });
                        });
            });
}

function resendActivationEmail(client, resendActivation) {
  return findUserByEmail(client, resendActivation.email).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
              if (user.isActivated) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "AlreadyActivated"
                          });
              }
              var activationKey = user.activationKey;
              if (activationKey === null) {
                return Js_exn.raiseError("Activation key missing");
              }
              var userId = Curry._1(MongoDb.ObjectId.toString, user._id);
              return Server_Email.sendActivationEmail(userId, user.email, activationKey).then(function (param) {
                          return Promise.resolve({
                                      TAG: /* Ok */0,
                                      _0: undefined
                                    });
                        });
            });
}

function signup(client, signup$1) {
  return validateSignup(client, signup$1).then(function (errors) {
              if (Common_User.Signup.hasErrors(errors)) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: errors
                          });
              } else {
                return signupToUser(signup$1).then(function (param) {
                              return insertUser(client, param);
                            }).then(function (user) {
                            var activationKey = user.activationKey;
                            if (activationKey === null) {
                              return Js_exn.raiseError("Activation key not found after signup");
                            }
                            var userId = Curry._1(MongoDb.ObjectId.toString, user._id);
                            return Server_Email.sendActivationEmail(userId, user.email, activationKey).then(function (param) {
                                        return {
                                                TAG: /* Ok */0,
                                                _0: undefined
                                              };
                                      });
                          });
              }
            });
}

function login(client, login$1) {
  var errors = Common_User.Login.validateLogin(login$1);
  if (Common_User.Login.hasErrors(errors)) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: errors
              });
  } else {
    return findUserByEmail(client, login$1.email).then(function (user) {
                if (user !== undefined) {
                  if (user.isActivated) {
                    return Bcrypt.compare(login$1.password, user.passwordHash).then(function (compareResult) {
                                return Promise.resolve(compareResult ? ({
                                                TAG: /* Ok */0,
                                                _0: user
                                              }) : ({
                                                TAG: /* Error */1,
                                                _0: {
                                                  login: "LoginFailed",
                                                  email: undefined,
                                                  password: undefined
                                                }
                                              }));
                              });
                  } else {
                    return Promise.resolve({
                                TAG: /* Error */1,
                                _0: {
                                  login: "AccountNotActivated",
                                  email: undefined,
                                  password: undefined
                                }
                              });
                  }
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                login: "LoginFailed",
                                email: undefined,
                                password: undefined
                              }
                            });
                }
              });
  }
}

function setIsActivated(client, userId) {
  var update = {
    isActivated: true,
    activationKey: null
  };
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
}

function activate(client, userId, activationKey) {
  return findUserByStringId(client, userId).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
              if (user.isActivated) {
                return Promise.resolve({
                            TAG: /* Ok */0,
                            _0: undefined
                          });
              }
              var userActivationKey = user.activationKey;
              if (userActivationKey !== null) {
                if (userActivationKey === activationKey) {
                  return setIsActivated(client, user._id).then(function (_updateResult) {
                              return Promise.resolve({
                                          TAG: /* Ok */0,
                                          _0: undefined
                                        });
                            });
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: "IncorrectActivationKey"
                            });
                }
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "ActivationKeyMissing"
                          });
              }
            });
}

function setPassword(client, userId, password) {
  return hashPassword(password).then(function (passwordHash) {
              var update = passwordFields(passwordHash, null, null);
              return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
            });
}

function changePassword(client, userId, changePassword$1) {
  var errors = Common_User.ChangePassword.validateChangePassword(changePassword$1);
  if (Common_User.ChangePassword.hasErrors(errors)) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: errors
              });
  } else {
    return findUserByObjectId(client, userId).then(function (user) {
                if (user !== undefined) {
                  if (user.isActivated) {
                    return Bcrypt.compare(changePassword$1.currentPassword, user.passwordHash).then(function (compareResult) {
                                if (compareResult) {
                                  return setPassword(client, userId, changePassword$1.newPassword).then(function (param) {
                                              return Promise.resolve({
                                                          TAG: /* Ok */0,
                                                          _0: undefined
                                                        });
                                            });
                                } else {
                                  return Promise.resolve({
                                              TAG: /* Error */1,
                                              _0: {
                                                changePassword: "CurrentPasswordInvalid",
                                                currentPassword: undefined,
                                                newPassword: undefined,
                                                newPasswordConfirm: undefined
                                              }
                                            });
                                }
                              });
                  } else {
                    return Promise.resolve({
                                TAG: /* Error */1,
                                _0: {
                                  changePassword: "AccountNotActivated",
                                  currentPassword: undefined,
                                  newPassword: undefined,
                                  newPasswordConfirm: undefined
                                }
                              });
                  }
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changePassword: "UserNotFound",
                                currentPassword: undefined,
                                newPassword: undefined,
                                newPasswordConfirm: undefined
                              }
                            });
                }
              });
  }
}

function setEmailChange(client, userId, emailChange, emailChangeKey) {
  var update = emailChangeFields(emailChange, emailChangeKey, AddHours(new Date(), 1));
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
}

function changeEmail(client, userId, changeEmail$1) {
  var errors = Common_User.ChangeEmail.validateChangeEmail(changeEmail$1);
  if (Common_User.ChangeEmail.hasErrors(errors)) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: errors
              });
  } else {
    return findUserByObjectId(client, userId).then(function (user) {
                if (user === undefined) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changeEmail: "UserNotFound",
                                email: undefined
                              }
                            });
                }
                if (!user.isActivated) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changeEmail: "AccountNotActivated",
                                email: undefined
                              }
                            });
                }
                var emailTrimmed = $$String.trim(changeEmail$1.email);
                if (emailTrimmed === user.email) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changeEmail: "SameAsCurrentEmail",
                                email: undefined
                              }
                            });
                } else {
                  return checkIfEmailIsTaken(client, emailTrimmed).then(function (isTaken) {
                              if (isTaken) {
                                return Promise.resolve({
                                            TAG: /* Error */1,
                                            _0: {
                                              changeEmail: "EmailNotAvailable",
                                              email: undefined
                                            }
                                          });
                              }
                              var emailChangeKey = Curry._1(makeEmailChangeKey, undefined);
                              return setEmailChange(client, userId, emailTrimmed, emailChangeKey).then(function (param) {
                                          var userId = Curry._1(MongoDb.ObjectId.toString, user._id);
                                          return Server_Email.sendEmailChangeEmail(userId, changeEmail$1.email, emailChangeKey).then(function (param) {
                                                      return Promise.resolve({
                                                                  TAG: /* Ok */0,
                                                                  _0: {
                                                                    changeEmail: undefined,
                                                                    email: undefined
                                                                  }
                                                                });
                                                    });
                                        });
                            });
                }
              });
  }
}

function setEmail(client, userId, email) {
  var update = emailFields(email, null, null, null);
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
}

function changeEmailConfirm(client, userId, emailChangeKey) {
  return findUserByStringId(client, userId).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
              var currentEmailChange = user.emailChange;
              var currentEmailChangeKey = user.emailChangeKey;
              if (currentEmailChange == null) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "EmailChangeMissing"
                          });
              } else if (currentEmailChangeKey == null) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "EmailChangeKeyMissing"
                          });
              } else if (currentEmailChangeKey === emailChangeKey) {
                return setEmail(client, user._id, currentEmailChange).then(function (_updateResult) {
                            return Promise.resolve({
                                        TAG: /* Ok */0,
                                        _0: undefined
                                      });
                          });
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "IncorrectEmailChangeKey"
                          });
              }
            });
}

function setResetPasswordKey(client, userId, resetPasswordKey) {
  var resetPasswordExpiry = AddHours(new Date(), 1);
  var update = resetPasswordFields(resetPasswordKey, resetPasswordExpiry);
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
}

function forgotPassword(client, forgotPassword$1) {
  return findUserByEmail(client, forgotPassword$1.email).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "EmailNotFound"
                          });
              }
              if (!user.isActivated) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "AccountNotActivated"
                          });
              }
              var resetPasswordKey = Curry._1(makeResetPasswordKey, undefined);
              return setResetPasswordKey(client, user._id, resetPasswordKey).then(function (param) {
                          var userId = Curry._1(MongoDb.ObjectId.toString, user._id);
                          return Server_Email.sendForgotPasswordEmail(userId, user.email, resetPasswordKey).then(function (param) {
                                      return Promise.resolve({
                                                  TAG: /* Ok */0,
                                                  _0: undefined
                                                });
                                    });
                        });
            });
}

function validateResetPasswordKey(client, userId, resetPasswordKey) {
  return findUserByStringId(client, userId).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
              if (!user.isActivated) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "AccountNotActivated"
                          });
              }
              var userResetPasswordKey = user.resetPasswordKey;
              var userResetPasswordExpiry = user.resetPasswordExpiry;
              if (userResetPasswordKey !== null && userResetPasswordExpiry !== null) {
                if (Common_Date.isInThePast(userResetPasswordExpiry)) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: "ResetPasswordExpired"
                            });
                } else if (userResetPasswordKey !== resetPasswordKey) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: "ResetPasswordKeyInvalid"
                            });
                } else {
                  return Promise.resolve({
                              TAG: /* Ok */0,
                              _0: undefined
                            });
                }
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "ResetPasswordNotRequested"
                          });
              }
            });
}

function resetPassword(client, resetPassword$1) {
  var userId = MongoDb.ObjectId.fromString(resetPassword$1.userId);
  if (userId.TAG !== /* Ok */0) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: {
                  resetPassword: "ResetPasswordInvalid",
                  password: undefined,
                  passwordConfirm: undefined,
                  reCaptcha: undefined
                }
              });
  }
  var userId$1 = userId._0;
  var errors = Common_User.ResetPassword.validateResetPassword(resetPassword$1);
  if (Common_User.ResetPassword.hasErrors(errors)) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: errors
              });
  } else {
    return validateReCaptchaToken(resetPassword$1.reCaptcha).then(function (reCaptchaError) {
                if (reCaptchaError === undefined) {
                  return validateResetPasswordKey(client, resetPassword$1.userId, resetPassword$1.resetPasswordKey).then(function (result) {
                              if (result.TAG === /* Ok */0) {
                                return setPassword(client, userId$1, resetPassword$1.password).then(function (param) {
                                            return Promise.resolve({
                                                        TAG: /* Ok */0,
                                                        _0: undefined
                                                      });
                                          });
                              }
                              var validation_resetPassword = Common_User.ResetPassword.refineResetPasswordKeyError(result._0);
                              var validation = {
                                resetPassword: validation_resetPassword,
                                password: undefined,
                                passwordConfirm: undefined,
                                reCaptcha: undefined
                              };
                              return Promise.resolve({
                                          TAG: /* Error */1,
                                          _0: validation
                                        });
                            });
                }
                var errors_reCaptcha = reCaptchaError;
                var errors = {
                  resetPassword: undefined,
                  password: undefined,
                  passwordConfirm: undefined,
                  reCaptcha: errors_reCaptcha
                };
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: errors
                          });
              });
  }
}

export {
  User ,
  toCommonUser ,
  toCommonUserDto ,
  toNullCommonUserDto ,
  getCollection ,
  getStats ,
  hashPassword ,
  comparePasswords ,
  makeActivationKey ,
  makeResetPasswordKey ,
  makeEmailChangeKey ,
  makeEmailChangeKeyExpiry ,
  makeResetPasswordExpiry ,
  signupToUser ,
  findUserByObjectId ,
  findUserByStringId ,
  insertUser ,
  findUserByEmail ,
  checkIfEmailIsTaken ,
  validateEmailIsAvailable ,
  validateReCaptchaToken ,
  validateSignup ,
  resendActivationEmail ,
  signup ,
  login ,
  setIsActivated ,
  activate ,
  setPassword ,
  changePassword ,
  setEmailChange ,
  changeEmail ,
  setEmail ,
  changeEmailConfirm ,
  setResetPasswordKey ,
  forgotPassword ,
  validateResetPasswordKey ,
  resetPassword ,
  
}
/* makeActivationKey Not a pure module */
