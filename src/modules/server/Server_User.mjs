// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Bcrypt from "bcrypt";
import * as Nanoid from "nanoid";
import * as MongoDb from "../../bindings/MongoDb.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Common_User from "../common/Common_User.mjs";
import * as Server_ReCaptcha from "./Server_ReCaptcha.mjs";

function getCollection(client) {
  var db = client.db();
  return db.collection("users");
}

function getStats(client) {
  return getCollection(client).stats();
}

function hashPassword(password) {
  return Bcrypt.genSalt(10).then(function (salt) {
              return Bcrypt.hash(password, salt);
            });
}

function comparePasswords(password, passwordHash) {
  return Bcrypt.compare(password, passwordHash);
}

function makeActivationKey(param) {
  return Curry._1(Nanoid.nanoid, undefined);
}

function makeResetPasswordKey(param) {
  return Curry._1(Nanoid.nanoid, undefined);
}

function makeEmailChangeKey(param) {
  return Curry._1(Nanoid.nanoid, undefined);
}

function signupToDbUser(signup) {
  var now = new Date();
  return hashPassword(signup.password).then(function (passwordHash) {
              return Promise.resolve({
                          _id: Curry._1(MongoDb.ObjectId.make, undefined),
                          email: signup.email,
                          emailVerified: false,
                          passwordHash: passwordHash,
                          created: now,
                          updated: now,
                          activationKey: Curry._1(Nanoid.nanoid, undefined),
                          isActivated: false,
                          resetPasswordKey: undefined,
                          resetPasswordExpiry: undefined
                        });
            });
}

function findUserByObjectId(client, objectId) {
  return getCollection(client).findOne({
                _id: objectId
              }).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function findUserByStringId(client, userId) {
  var userId$1 = MongoDb.ObjectId.fromString(userId);
  if (userId$1.TAG === /* Ok */0) {
    return getCollection(client).findOne({
                  _id: userId$1._0
                }).then(function (prim) {
                if (prim === undefined) {
                  return ;
                } else {
                  return Caml_option.some(prim);
                }
              });
  } else {
    return Promise.resolve(undefined);
  }
}

function insertUser(client, dbUser) {
  return getCollection(client).insertOne(dbUser).then(function (insertResult) {
              return findUserByObjectId(client, insertResult.insertedId);
            });
}

function findUserByEmail(client, email) {
  return getCollection(client).findOne({
                email: email
              }).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function updateUserPassword(client, userId, password) {
  var userId$1 = MongoDb.ObjectId.fromString(userId);
  if (userId$1.TAG === /* Ok */0) {
    return MongoDb.Collection.updateOneWithSet(getCollection(client), userId$1._0, {
                password: password
              });
  } else {
    return Js_exn.raiseError(userId$1._0);
  }
}

function updateEmailVerified(client, userId, emailVerified) {
  var userId$1 = MongoDb.ObjectId.fromString(userId);
  if (userId$1.TAG === /* Ok */0) {
    return MongoDb.Collection.updateOneWithSet(getCollection(client), userId$1._0, {
                emailVerified: emailVerified
              });
  } else {
    return Js_exn.raiseError(userId$1._0);
  }
}

function checkIfEmailIsTaken(client, email) {
  return getCollection(client).find({
                  $or: [
                    {
                      email: email
                    },
                    {
                      emailChange: email
                    }
                  ]
                }).toArray().then(function (dbUsers) {
              return Promise.resolve(dbUsers.length > 0);
            });
}

function validateEmailIsAvailable(client, email) {
  var emailTrimmed = $$String.trim(email);
  return checkIfEmailIsTaken(client, emailTrimmed).then(function (isTaken) {
              return Promise.resolve(isTaken ? "EmailNotAvailable" : undefined);
            });
}

function validateReCaptchaToken(token) {
  if (token !== undefined) {
    return Server_ReCaptcha.verifyToken(token).then(function (result) {
                if (result.TAG === /* Ok */0) {
                  return Promise.resolve(undefined);
                } else {
                  return Promise.resolve("ReCaptchaInvalid");
                }
              });
  } else {
    return Promise.resolve("ReCaptchaEmpty");
  }
}

function validateSignup(client, signup) {
  var validation = Common_User.Signup.validateSignup(signup);
  if (Common_User.Signup.hasErrors(validation)) {
    return Promise.resolve(validation);
  }
  var emailTrimmed = $$String.trim(signup.email);
  var emailPromise = validateEmailIsAvailable(client, emailTrimmed);
  var reCaptchaPromise = validateReCaptchaToken(signup.reCaptcha);
  return emailPromise.then(function (emailError) {
              return reCaptchaPromise.then(function (reCaptchaError) {
                          return Promise.resolve({
                                      email: emailError,
                                      password: undefined,
                                      reCaptcha: reCaptchaError
                                    });
                        });
            });
}

function signup(client, signup$1) {
  return validateSignup(client, signup$1).then(function (validation) {
              if (Common_User.Signup.isValid(validation)) {
                return signupToDbUser(signup$1).then(function (param) {
                              return insertUser(client, param);
                            }).then(function (param) {
                            return Promise.resolve({
                                        TAG: /* Ok */0,
                                        _0: validation
                                      });
                          });
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: validation
                          });
              }
            });
}

export {
  getCollection ,
  getStats ,
  hashPassword ,
  comparePasswords ,
  makeActivationKey ,
  makeResetPasswordKey ,
  makeEmailChangeKey ,
  signupToDbUser ,
  findUserByObjectId ,
  findUserByStringId ,
  insertUser ,
  findUserByEmail ,
  updateUserPassword ,
  updateEmailVerified ,
  checkIfEmailIsTaken ,
  validateEmailIsAvailable ,
  validateReCaptchaToken ,
  validateSignup ,
  signup ,
  
}
/* bcrypt Not a pure module */
