// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Bcrypt from "bcrypt";
import * as Nanoid from "nanoid";
import * as MongoDb from "../../bindings/MongoDb.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Common_User from "../common/Common_User.mjs";
import * as Server_Email from "./Server_Email.mjs";
import * as Server_ReCaptcha from "./Server_ReCaptcha.mjs";
import AddHours from "date-fns/addHours";

function idField(id) {
  return {
          _id: id
        };
}

function emailField(email) {
  return {
          email: email
        };
}

function emailQuery(email) {
  return {
          $or: [
            {
              email: email
            },
            {
              emailChange: email
            }
          ]
        };
}

function activationFields(isActivated, activationKey) {
  return {
          isActivated: isActivated,
          activationKey: activationKey
        };
}

function passwordFields(passwordHash, resetPasswordKey, resetPasswordExpiry) {
  return {
          passwordHash: passwordHash,
          resetPasswordKey: resetPasswordKey,
          resetPasswordExpiry: resetPasswordExpiry
        };
}

function emailChangeFields(emailChange, emailChangeKey, emailChangeKeyExpiry) {
  return {
          emailChange: emailChange,
          emailChangeKey: emailChangeKey,
          emailChangeKeyExpiry: emailChangeKeyExpiry
        };
}

function emailFields(email, emailChange, emailChangeKey, emailChangeKeyExpiry) {
  return {
          email: email,
          emailChange: emailChange,
          emailChangeKey: emailChangeKey,
          emailChangeKeyExpiry: emailChangeKeyExpiry
        };
}

var User = {
  idField: idField,
  emailField: emailField,
  emailQuery: emailQuery,
  activationFields: activationFields,
  passwordFields: passwordFields,
  emailChangeFields: emailChangeFields,
  emailFields: emailFields
};

function toCommonUser(user) {
  return {
          id: Curry._1(MongoDb.ObjectId.toString, user._id),
          email: user.email,
          emailChange: Caml_option.nullable_to_opt(user.emailChange)
        };
}

function toCommonUserDto(user) {
  return Common_User.User.toDto(toCommonUser(user));
}

function getCollection(client) {
  var db = client.db();
  return db.collection("users");
}

function getStats(client) {
  return getCollection(client).stats();
}

function hashPassword(password) {
  return Bcrypt.genSalt(10).then(function (salt) {
              return Bcrypt.hash(password, salt);
            });
}

function comparePasswords(password, passwordHash) {
  return Bcrypt.compare(password, passwordHash);
}

var makeActivationKey = Nanoid.nanoid;

var makeResetPasswordKey = Nanoid.nanoid;

var makeEmailChangeKey = Nanoid.nanoid;

function makeEmailChangeKeyExpiry(param) {
  return AddHours(new Date(), 24);
}

function signupToUser(signup) {
  var now = new Date();
  return hashPassword(signup.password).then(function (passwordHash) {
              return Promise.resolve({
                          _id: Curry._1(MongoDb.ObjectId.make, undefined),
                          email: signup.email,
                          emailChange: null,
                          emailChangeKey: null,
                          emailChangeKeyExpiry: null,
                          passwordHash: passwordHash,
                          created: now,
                          updated: now,
                          activationKey: Curry._1(makeActivationKey, undefined),
                          isActivated: false,
                          resetPasswordKey: null,
                          resetPasswordExpiry: null
                        });
            });
}

function findUserByObjectId(client, objectId) {
  var query = {
    _id: objectId
  };
  return getCollection(client).findOne(query).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function insertUser(client, user) {
  return getCollection(client).insertOne(user).then(function (insertResult) {
              return findUserByObjectId(client, insertResult.insertedId).then(function (user) {
                          if (user !== undefined) {
                            return Promise.resolve(user);
                          } else {
                            return Js_exn.raiseError("User not found after insert");
                          }
                        });
            });
}

function findUserByEmail(client, email) {
  var query = {
    email: email
  };
  return getCollection(client).findOne(query).then(function (prim) {
              if (prim === undefined) {
                return ;
              } else {
                return Caml_option.some(prim);
              }
            });
}

function checkIfEmailIsTaken(client, email) {
  return getCollection(client).find(emailQuery(email)).toArray().then(function (users) {
              return Promise.resolve(users.length > 0);
            });
}

function validateEmailIsAvailable(client, email) {
  var emailTrimmed = $$String.trim(email);
  return checkIfEmailIsTaken(client, emailTrimmed).then(function (isTaken) {
              return Promise.resolve(isTaken ? "EmailNotAvailable" : undefined);
            });
}

function validateReCaptchaToken(token) {
  if (token !== undefined) {
    return Server_ReCaptcha.verifyToken(token).then(function (result) {
                if (result.TAG === /* Ok */0) {
                  return Promise.resolve(undefined);
                } else {
                  return Promise.resolve("ReCaptchaInvalid");
                }
              });
  } else {
    return Promise.resolve("ReCaptchaEmpty");
  }
}

function validateSignup(client, signup) {
  var validation = Common_User.Signup.validateSignup(signup);
  if (Common_User.Signup.hasErrors(validation)) {
    return Promise.resolve(validation);
  }
  var emailTrimmed = $$String.trim(signup.email);
  var emailPromise = validateEmailIsAvailable(client, emailTrimmed);
  var reCaptchaPromise = validateReCaptchaToken(signup.reCaptcha);
  return emailPromise.then(function (emailError) {
              return reCaptchaPromise.then(function (reCaptchaError) {
                          return Promise.resolve({
                                      email: emailError,
                                      password: undefined,
                                      reCaptcha: reCaptchaError
                                    });
                        });
            });
}

function signup(client, signup$1) {
  return validateSignup(client, signup$1).then(function (validation) {
              if (Common_User.Signup.isValid(validation)) {
                return signupToUser(signup$1).then(function (param) {
                              return insertUser(client, param);
                            }).then(function (user) {
                            var activationKey = user.activationKey;
                            if (activationKey === null) {
                              return Js_exn.raiseError("Activation key not found after signup");
                            }
                            var userId = Curry._1(MongoDb.ObjectId.toString, user._id);
                            return Server_Email.sendActivationEmail(userId, user.email, activationKey).then(function (param) {
                                        return Promise.resolve({
                                                    TAG: /* Ok */0,
                                                    _0: validation
                                                  });
                                      });
                          });
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: validation
                          });
              }
            });
}

function login(client, login$1) {
  return findUserByEmail(client, login$1.email).then(function (user) {
              if (user !== undefined) {
                if (user.isActivated) {
                  return Bcrypt.compare(login$1.password, user.passwordHash).then(function (compareResult) {
                              return Promise.resolve(compareResult ? ({
                                              TAG: /* Ok */0,
                                              _0: user
                                            }) : ({
                                              TAG: /* Error */1,
                                              _0: "PasswordInvalid"
                                            }));
                            });
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: "AccountInactive"
                            });
                }
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
            });
}

function setIsActivated(client, userId) {
  var update = {
    isActivated: true,
    activationKey: null
  };
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
}

function activate(client, userId, activationKey) {
  return findUserByObjectId(client, userId).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "UserNotFound"
                          });
              }
              if (user.isActivated) {
                return Promise.resolve({
                            TAG: /* Ok */0,
                            _0: undefined
                          });
              }
              var userActivationKey = user.activationKey;
              if (userActivationKey !== null) {
                if (userActivationKey === activationKey) {
                  return setIsActivated(client, userId).then(function (_updateResult) {
                              return Promise.resolve({
                                          TAG: /* Ok */0,
                                          _0: undefined
                                        });
                            });
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: "IncorrectActivationKey"
                            });
                }
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: "ActivationKeyMissing"
                          });
              }
            });
}

function setPassword(client, userId, password) {
  return hashPassword(password).then(function (passwordHash) {
              var update = passwordFields(passwordHash, null, null);
              return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
            });
}

function changePassword(client, userId, changePassword$1) {
  var validation = Common_User.ChangePassword.validateChangePassword(changePassword$1);
  if (Common_User.ChangePassword.hasErrors(validation)) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: validation
              });
  } else {
    return findUserByObjectId(client, userId).then(function (user) {
                if (user !== undefined) {
                  if (user.isActivated) {
                    return Bcrypt.compare(changePassword$1.currentPassword, user.passwordHash).then(function (compareResult) {
                                if (compareResult) {
                                  return setPassword(client, userId, changePassword$1.newPassword).then(function (param) {
                                              return Promise.resolve({
                                                          TAG: /* Ok */0,
                                                          _0: validation
                                                        });
                                            });
                                } else {
                                  return Promise.resolve({
                                              TAG: /* Error */1,
                                              _0: {
                                                changePassword: "CurrentPasswordInvalid",
                                                currentPassword: undefined,
                                                newPassword: undefined,
                                                newPasswordConfirm: undefined
                                              }
                                            });
                                }
                              });
                  } else {
                    return Promise.resolve({
                                TAG: /* Error */1,
                                _0: {
                                  changePassword: "AccountNotActivated",
                                  currentPassword: undefined,
                                  newPassword: undefined,
                                  newPasswordConfirm: undefined
                                }
                              });
                  }
                } else {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changePassword: "UserNotFound",
                                currentPassword: undefined,
                                newPassword: undefined,
                                newPasswordConfirm: undefined
                              }
                            });
                }
              });
  }
}

function setEmailChange(client, userId, emailChange, emailChangeKey) {
  var update = emailChangeFields(emailChange, emailChangeKey, AddHours(new Date(), 24));
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
}

function changeEmail(client, userId, changeEmail$1) {
  var errors = Common_User.ChangeEmail.validateChangeEmail(changeEmail$1);
  if (Common_User.ChangeEmail.hasErrors(errors)) {
    return Promise.resolve({
                TAG: /* Error */1,
                _0: errors
              });
  } else {
    return findUserByObjectId(client, userId).then(function (user) {
                if (user === undefined) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changeEmail: "UserNotFound",
                                email: undefined
                              }
                            });
                }
                if (!user.isActivated) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changeEmail: "AccountNotActivated",
                                email: undefined
                              }
                            });
                }
                var emailTrimmed = $$String.trim(changeEmail$1.email);
                if (emailTrimmed === user.email) {
                  return Promise.resolve({
                              TAG: /* Error */1,
                              _0: {
                                changeEmail: "SameAsCurrentEmail",
                                email: undefined
                              }
                            });
                } else {
                  return checkIfEmailIsTaken(client, emailTrimmed).then(function (isTaken) {
                              if (isTaken) {
                                return Promise.resolve({
                                            TAG: /* Error */1,
                                            _0: {
                                              changeEmail: "EmailNotAvailable",
                                              email: undefined
                                            }
                                          });
                              }
                              var emailChangeKey = Curry._1(makeEmailChangeKey, undefined);
                              return setEmailChange(client, userId, emailTrimmed, emailChangeKey).then(function (param) {
                                          var userId = Curry._1(MongoDb.ObjectId.toString, user._id);
                                          return Server_Email.sendEmailChangeEmail(userId, changeEmail$1.email, emailChangeKey).then(function (param) {
                                                      return Promise.resolve({
                                                                  TAG: /* Ok */0,
                                                                  _0: {
                                                                    changeEmail: undefined,
                                                                    email: undefined
                                                                  }
                                                                });
                                                    });
                                        });
                            });
                }
              });
  }
}

function setEmail(client, userId, email) {
  var update = emailFields(email, null, null, null);
  return MongoDb.Collection.updateOneWithSet(getCollection(client), userId, update);
}

function changeEmailConfirm(client, userId, emailChangeKey) {
  return findUserByObjectId(client, userId).then(function (user) {
              if (user === undefined) {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: undefined
                          });
              }
              var currentEmailChange = user.emailChange;
              var currentEmailChangeKey = user.emailChangeKey;
              if (!(currentEmailChange == null) && !(currentEmailChangeKey == null) && currentEmailChangeKey === emailChangeKey) {
                return setEmail(client, userId, currentEmailChange).then(function (_updateResult) {
                            return Promise.resolve({
                                        TAG: /* Ok */0,
                                        _0: undefined
                                      });
                          });
              } else {
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: undefined
                          });
              }
            });
}

export {
  User ,
  toCommonUser ,
  toCommonUserDto ,
  getCollection ,
  getStats ,
  hashPassword ,
  comparePasswords ,
  makeActivationKey ,
  makeResetPasswordKey ,
  makeEmailChangeKey ,
  makeEmailChangeKeyExpiry ,
  signupToUser ,
  findUserByObjectId ,
  insertUser ,
  findUserByEmail ,
  checkIfEmailIsTaken ,
  validateEmailIsAvailable ,
  validateReCaptchaToken ,
  validateSignup ,
  signup ,
  login ,
  setIsActivated ,
  activate ,
  setPassword ,
  changePassword ,
  setEmailChange ,
  changeEmail ,
  setEmail ,
  changeEmailConfirm ,
  
}
/* makeActivationKey Not a pure module */
